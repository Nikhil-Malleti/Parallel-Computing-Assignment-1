/*
Name - Malleti Sai Nikhil
Roll no - CS21M009
M.tech , 1st year , CSE

Note :- I used function that are only available from c++17

My method to select cells randomly

- for the n*m or m*p value less than a certain value (10^7) i just generated the array of that size and sampled required number of cells
    from that array by using sample fuction which will select the given number of values randomly

- i filled the selected cells with random values

My method of storing sparse matrix

- I stored elements in the same row in one vector , and i only stored non zero elements
  element are stored in increasing order of their column number although this is not required in sparse multiplication algorithm i designed

My method of multiplying sparse matrix

- I noticed that the effect of one element in the multiplication is that it will scale the entire row of second matrix
- So i just calculated the effect of one element at a time

- For timing and also to validate the matrix generated by the sparse multiplication is same as simple multiplication
  while generating the sparse matrix , i also generated simple matrix stored in 2d array

*/

#include<iostream>
#include<vector>
#include<algorithm>
#include<random>
#include<chrono>
#include<unordered_set>

using namespace std;

// Definitions
#define MAX_MATRIX_SIZE 10000000
#define MAX_NUMBER_OF_ELEMENTS 10000000
#define MAX_NUMBER_OF_ROWS 10000000
#define MAX_NUMBER_OF_COLUMNS 10000000

// Macros
#define to_row(n,c) n/c
#define to_column(n,c) n%c

// This class is to measure time

class mytimer {
	decltype(chrono::high_resolution_clock::now()) tstart, tend;
public:
	mytimer() {
		tstart = chrono::high_resolution_clock::now();
	}
	void timetaken() {
		tend = chrono::high_resolution_clock::now();
		auto dur = chrono::duration_cast<chrono::nanoseconds>(tend - tstart);
		cout << "\n\n\tTime taken ------ " <<
			dur.count() / ((long long)1000 * 1000 * 1000 * 60) << " min  " <<
			(dur.count() / ((long long)1000 * 1000 * 1000)) % 60 << " sec  " <<
			(dur.count() / (1000 * 1000)) % 1000 << " ms  " <<
			(dur.count() / 1000) % 1000 << " us  " <<
			dur.count() % 1000 << " ns\n";
	}
	void reset() {
		tstart = chrono::high_resolution_clock::now();
	}
};

// This class is to store the Simple matrix , i will call it dense matrix

class Matrix {
public:
	int row;
	int columns;
	vector<vector<long long int>> elem;

	Matrix(int r, int c) : row(r), columns(c) {
		elem.resize(r);
		for (int i = 0; i < r; ++i) {
			elem[i].resize(c);
		}
	}

	Matrix(Matrix& m) : row(m.row), columns(m.columns) {
		elem.resize(row);
		for (int i = 0; i < row; ++i) {
			elem[i].resize(columns);
		}
		for (int i = 0; i < row; ++i) {
			for (int k = 0; k < columns; ++k) {
				elem[i][k] = m.elem[i][k];
			}
		}
	}

};

// Simple Matrix multiplication

Matrix& operator*=(Matrix& m1, Matrix& m2) {

	// mul check
	if (m1.columns != m2.row) {
		cout << "can not multiply matrix\n";
		exit(-1);
	}

	Matrix temp(m1);

	if (m1.columns != m2.columns) {
		for (int i = 0; i < m1.row; ++i) {
			m1.elem[i].resize(m2.columns);
		}
		m1.columns = m2.columns;
	}

	for (int i = 0; i < m1.row; ++i) {
		for (int k = 0; k < m2.columns; ++k) {
			int colf = 0;
			int rowd = 0;
			m1.elem[i][k] = 0;
			while (colf < temp.columns)
			{
				m1.elem[i][k] += temp.elem[i][colf++] * m2.elem[rowd++][k];
			}
		}
	}

	return m1;
}

// Element class to store value and column numbers

class element {
public:
	int value;
	int column;
};

//Function to select cells randomly

void select_cells_random(int n, int noe, vector<int>& sel) {
	if (n <= 10000000) {
		vector<int> cells(n);
		for (int i = 0; i < n; ++i) cells[i] = i; // populating vector with values from 0 to n-1

		sample(cells.begin(), cells.end(), back_inserter(sel), noe, mt19937{ random_device{}() }); // selecting noe number of elments from 0 to n-1 randomly

	}
	else {

		unordered_set<int> already_selected; // to check wheather the cell is already selected or not
		int rem = noe;
		//srand(25) 
		while (rem)
		{
			//if(RAND_MAX <= 32767)
			int num = (rand() * rand()) % n;

			if (already_selected.find(num) == already_selected.end()) {
				already_selected.insert(num);
				sel.push_back(num);
				--rem;
			}

		}

		sort(sel.begin(), sel.end());
	}
}

// Sparse Matrix Class

class sparse_matrix {
public:
	int rows;
	int columns;
	vector<vector<element>> row_array; // This vector contains vectors of each row elements
	Matrix dense_matrix;

	sparse_matrix(int r, int c, long double sparsity) : rows(r), columns(c), dense_matrix(r, c) {
		// Size checking
		int num_of_elm = static_cast<int>(floor(r * c * (1 - sparsity)));
		if (!num_of_elm) {
			cout << "number of non zero elements in given matrix is very close to zero\n";
			exit(-1);
		}
		if (num_of_elm > MAX_NUMBER_OF_ELEMENTS) {
			cout << "Very Large array";
			exit(-1);
		}
		row_array.resize(rows);

		vector<int> selected;
		select_cells_random(r * c, num_of_elm, selected); // This will select the cells randomly
		construct_matrix(selected); // This will construct sparse and dense matrix

	}

	// Function to construct sparse and dense matrix

	void construct_matrix(vector<int>& selected) {

		for (int i = 0; i < selected.size(); ++i) {

			int cell_row = to_row(selected[i], columns);
			int cell_column = to_column(selected[i], columns);

			int val = rand() % 10 + 1;
			dense_matrix.elem[cell_row][cell_column] = val;

			row_array[cell_row].push_back({ val,cell_column });

		}

	}
};

void sparse_matrix_mul(sparse_matrix& s1, sparse_matrix& s2, Matrix& m) {

	// Compatability checking
	if (s1.columns != s2.rows) {
		cout << "Matrix can not be multiplied because their columns and rows does not match\n";
		exit(-1);
	}
	if ((m.row != s1.rows) || (m.columns != s2.columns)) {
		cout << "Dense matrix does not have the same dimension as the resultant matrix\n";
		exit(-1);
	}

	for (int i = 0; i < s1.rows; ++i) {

		for (int k = 0; k < s1.row_array[i].size(); ++k) {

			element e = s1.row_array[i][k];

			for (int l = 0; l < s2.row_array[e.column].size(); ++l) {

				element e2 = s2.row_array[e.column][l];
				m.elem[i][e2.column] += e.value * e2.value;

			}

		}

	}

}

int main() {

	vector<int> select;
	vector<int> population;

	int m, n, p;
	long double spa, spb;

	m = 100;
	n = 500;
	p = 200;

	spa = spb = 0.8;

	mytimer timer;

	sparse_matrix a(m, n, spa);
	sparse_matrix b(n, p, spb);


	Matrix res(m, p);

	timer.reset();
	sparse_matrix_mul(a, b, res);
	cout << "Sparse Multiplication";
	timer.timetaken();

	timer.reset();
	a.dense_matrix *= b.dense_matrix;
	cout << "\nSimple Multiplication";
	timer.timetaken();

	// Checking whether the matrices calculated by two methods same or not

	for (int i = 0; i < m; ++i) {
		for (int k = 0; k < p; ++k) if (res.elem[i][k] != a.dense_matrix.elem[i][k]) {
			cout << "Not matching at " << i << " " << k << "\n";
			exit(-1);
		}
	}

	//timer.timetaken();

	return 0;
}